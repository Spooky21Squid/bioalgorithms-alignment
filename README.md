# Bioalgorithms-Alignment
This repo contains programs that can perform sequence to profile, profile to profile and cumulative profile alignment.

# Project Structure
## Code
### nw.py
This performs sequence to sequence, profile to sequence or profile to profile alignment on a collection of protein sequences.

### align.py
This calculates a high-scoring alignment on a collection of protein sequences.

## Data
Some sample profiles are provided under the 'profiles' directory.

Files for nw.py follow this format: Number of sequences in the first profile on the first line followed by one sequence per line, then the number of sequences in the second profile followed by one sequence per line again.

Files for align.py follow this format: Number of sequences in the profile followed by one sequence per line.

### Unsolved
The 'profiles/unsolved' directory contains some sample sequence collections to use for align.py (eg. multiple32.txt), and one sample file containing 2 alignment to use for nw.py (nw-profiles.txt).

### Solved
The 'profiles/solved' directory contains some examples of solved profiles generated by align.py, and the score is appended to the profile's name (eg. multipe32-112671.txt).

# How to Use

## Requirements
This uses external modules located in requirements.txt, install them using: **pip install -r requirements.txt**

## nw.py
This program uses a modified needleman-wunsch and pairwise scoring to align 2 profiles.

### Usage:
python3 nw.py \<file\>
- \<file\> - The path to the file containing profiles to align

Run nw.py using python 3, and pass the path to the text file containing the profiles as an argument.
It will print out the score and the alignment in the console. Eg:
- **nw-profiles**: python3 nw.py profiles/unsolved/nw-profiles.txt

## align.py
align.py uses the same modified needleman-wunsch as nw.py and pairwise scoring to find a good initial alignment, and then uses simulated annealing with iterative refinement to try and find a better solution.

Sometimes this takes a while (~1 minute for 128 sequences) so to shorten the time, run it with a solved alignment using the '-y' flag. I also find that starting with a high scoring alignment generally has a higher chance of giving an even better one.

### Usage:
python3 align.py \[-y\] \<file\> \<t\> \<m\> \<y\>
- \[-y\] - Set this flag if the text file already contains an alignment. If the text file contains un-aligned sequences, leave this out
- \<file\> - The path to the file containing alignments
- \<t\> - The initial temperature for simulated annealing, default is 10
- \<m\> - The multiplier to reduce t by, default is 0.95
- \<y\> - The proportion of sequences that will be re-aligned every cycle, defaults to one sequence (Anything over 32 sequences and it is better to set this to 0)

The arguments t, m and y all need to be set together, or all left out to use the defaults

### Using Sample Profiles
When using the sample profiles, it will first find an initial alignment using the same code from nw.py, and then try and refine the solution. Some Examples:

- **multiple32**: python3 align.py profiles/unsolved/multiple32.txt
- **multiple32 with arguments**: python3 align.py profiles/unsolved/multiple32.txt 10 0.95 0.1

### Using solved profiles
When using the solved profiles, it will use the initial alignment and then try and refine it. Some Examples:

- **multiple32**: python3 align.py -y profiles/solved/multiple32-112671.txt
- **multiple32 with arguments**: python3 align.py -y profiles/solved/multiple32-112671.txt 10 0.95 0.1

### Choosing Arguments
You can set your own t (temperature), m (temp modifier), and y (proportion of re-aligned sequences) following the format above. Setting a higher t will (i think) allow worse solutions to be chosen more often, potentially leading to higher scores. The same will happen (again, i think) with m values closer to 1. Generally, y values higher than 0.2 will lead to slower iterating times, and i'm not clear on if it has much impact on the final solution.

For now, adjusting the gap penalty can be done by changing the method parameter from 8 to some other integer.

### Acknowledgements

Originally the simulated annealing idea came from <a href="https://ia800704.us.archive.org/view_archive.php?archive=/24/items/wikipedia-scholarly-sources-corpus/10.1093%252F0199267669.001.0001.zip&file=10.1093%252Fbioinformatics%252F10.4.419.pdf">this article</a>, which uses simulated annealing but a different method of calculating neighbouring solutions.

Tested on both Windows and Linux using Python 3.10